name: Security PR Scan
on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to scan'
        required: true
        default: 'main'

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # To get the full diff

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0.x'  # Using .NET 7

      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      # Get branch code
      - name: Get branch code
        id: branch-code
        run: |
          # Checkout the specified branch
          git checkout ${{ github.event.inputs.branch }}
          
          # List all files in the branch
          git ls-files > branch_files.txt
          echo "BRANCH_FILES=$(cat branch_files.txt | tr '\n' ' ')" >> $GITHUB_ENV
          
          # Create a zip of the code for analysis
          git archive --format=zip --output=./code.zip HEAD $(cat branch_files.txt)
          
          # Base64 encode the zip for inclusion in JSON payload
          echo "CODE_BASE64=$(base64 -w 0 ./code.zip)" >> $GITHUB_ENV

      # Send to Azure Checker AI
      - name: Security scan with Azure Checker AI
        id: security-scan
        run: |
          # Create the JSON payload with the security checker prompt
          cat > payload.json << 'EOL'
          {
            "prompt": "You are a security analysis AI with deep expertise in secure software development and the OWASP Top 10, SANS Top 25, and Microsoft Secure Development Lifecycle. When given a C# ASP.NET Core Web API codebase, perform a comprehensive review using general security context—threat modeling, defense-in-depth, least privilege, and secure-by-design principles. Specifically:\n\n1. **Contextual Awareness**\n   - Assume no prior knowledge of business rules; use general industry best practices and OWASP guidance.\n   - Consider common web-app threats (injection, broken auth, insecure deserialization, misconfigured CORS, etc.).\n\n2. **Attack Surface Analysis**\n   - Identify all entry points (controllers, endpoints, middleware).\n   - Map data flows: user input → processing → data store/file system → output.\n\n3. **Vulnerability Categories**\n   - **Injection:** SQL, OS, LDAP, etc.\n   - **Authentication & Authorization:** missing or misconfigured.\n   - **Data Validation & Encoding:** input/output sanitization, model binding.\n   - **Error & Exception Handling:** information disclosure via stack traces.\n   - **Configuration & Secrets Management:** hard-coded credentials, debug settings in production.\n   - **File I/O & Concurrency:** race conditions, insecure file writes.\n   - **Logging & Monitoring:** sensitive data leakage, missing audit trails.\n   - **Dependencies:** outdated libraries, known CVEs.\n\n4. **Risk Assessment**\n   - For each issue, assign a risk level (High, Medium, Low) based on impact and likelihood.\n   - Reference OWASP Top 10 categories where applicable.\n\n5. **Reporting**\n   - Output a numbered list of findings with:\n     1. **Title**\n     2. **Location** (file/line or snippet)\n     3. **Description** of the flaw and its context\n     4. **Risk Rating** and OWASP reference\n     5. **Remediation** recommendations\n\nDeliver a clear, actionable report that developers can follow to harden their C# Web API.",
            "code": "${{ env.CODE_BASE64 }}"
          }
          EOL
          
          # Send the request to Azure Checker AI
          RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.AZURE_CHECKER_KEY }}" \
            -d @payload.json \
            ${{ secrets.AZURE_CHECKER_ENDPOINT }})
          
          # Save the response to a file
          echo "$RESPONSE" > scan_results.json
          
          # Parse the response and create annotations
          echo "Parsing security scan results..."
          
          # Initialize counters
          HIGH_COUNT=0
          MEDIUM_COUNT=0
          LOW_COUNT=0
          
          # Process each finding
          echo "$RESPONSE" | jq -c '.findings[]?' | while read -r finding; do
            TITLE=$(echo "$finding" | jq -r '.title')
            FILE=$(echo "$finding" | jq -r '.location.file')
            LINE=$(echo "$finding" | jq -r '.location.line')
            DESCRIPTION=$(echo "$finding" | jq -r '.description')
            RISK=$(echo "$finding" | jq -r '.risk')
            
            # Count by risk level
            if [[ "$RISK" == "High" ]]; then
              ((HIGH_COUNT++))
            elif [[ "$RISK" == "Medium" ]]; then
              ((MEDIUM_COUNT++))
            elif [[ "$RISK" == "Low" ]]; then
              ((LOW_COUNT++))
            fi
            
            # Create GitHub annotation
            echo "::error file=${FILE},line=${LINE}::${TITLE}: ${DESCRIPTION}"
          done
          
          # Export counts for summary
          echo "HIGH_COUNT=$HIGH_COUNT" >> $GITHUB_ENV
          echo "MEDIUM_COUNT=$MEDIUM_COUNT" >> $GITHUB_ENV
          echo "LOW_COUNT=$LOW_COUNT" >> $GITHUB_ENV
          
          # Fail if high risk findings exist
          if [[ $HIGH_COUNT -gt 0 ]]; then
            echo "High risk security issues found. Failing the build."
            exit 1
          fi

      # Create job summary
      - name: Create security scan summary
        if: always()
        run: |
          echo "# Security Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Risk Level | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| High       | ${{ env.HIGH_COUNT }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Medium     | ${{ env.MEDIUM_COUNT }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Low        | ${{ env.LOW_COUNT }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ env.HIGH_COUNT }}" -gt 0 ]]; then
            echo "⚠️ **Build failed due to high risk security issues** ⚠️" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ env.MEDIUM_COUNT }}" -gt 0 || "${{ env.LOW_COUNT }}" -gt 0 ]]; then
            echo "⚠️ **Security issues found, but not failing the build** ⚠️" >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ **No security issues found** ✅" >> $GITHUB_STEP_SUMMARY
          fi
